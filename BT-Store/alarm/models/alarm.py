# -*- coding: utf-8 -*-
##############################################################################
#
#    Copyright (c) 2017 brain-tec AG (http://www.braintec-group.com)
#    All Right Reserved
#
#    See LICENSE file for full licensing details.
##############################################################################

from odoo import api, fields, models, _
from odoo.exceptions import ValidationError, AccessError
from odoo.tools import safe_eval

from datetime import date, datetime, timedelta
import pytz


# noinspection PyRedundantParentheses
class Alarm(models.Model):
    _name = 'alarm.alarm'
    _description = 'Alarm'
    _order = 'model_id ASC, name ASC'

    # ===============================
    # FUNCTIONS FOR FIELD DEFINITIONS
    # ===============================

    @api.depends('description')
    def _compute_description_128(self):
        for alarm in self:
            description_128 = ''

            if alarm.description:
                if len(alarm.description) <= 128:
                    description_128 = alarm.description
                else:
                    description_128 = '{0}...'.format(alarm.description[:125])

            alarm.description_128 = description_128

    @api.depends()
    def _compute_current_user_group(self):
        current_user_group = self.get_current_user_group()

        for alarm in self:
            alarm.current_user_group = current_user_group

    # ======
    # FIELDS
    # ======

    name = fields.Char(_('Name'), size=128, required=True,
                       help=_('Short descriptive name for the alarm. This name is assigned to all notifications '
                              'generated by this alarm.'))
    description = fields.Text(_('Description'),
                              help=_('Further details to better understand the purpose of this alarm'))
    description_128 = fields.Char(_('Description'), compute=_compute_description_128)
    triggered_on = fields.Datetime(_('Triggered on'), readonly=True)

    model_id = fields.Many2one('ir.model', _('Model'), required=True,
                               help=_('Model (e.g., Project Task, Lead...) whose records may trigger the generation of '
                                      'alarm notifications'))
    model_domain = fields.Text(_('Model Domain'),
                               help=_("Python domain used to select only records with certain characteristics. "
                                      "For example, we can configure an alarm to generate notifications only for "
                                      "records in the draft state and whose creator is me by using the following "
                                      "domain: "
                                      "['&', ('state', '=', 'draft'), ('create_uid', '=', my_uid)]\n\n"
                                      "The following variables and libraries are available:\n"
                                      "- my_uid: variable with my user ID.\n"
                                      "- date: library to manage dates (e.g., date.today())\n"
                                      "- datetime: library to manage date with times (e.g., datetime.now())\n"
                                      "- timedelta: library to manage time deltas (e.g., date.today() + "
                                      "timedelta(days=2))"))

    date_field_id = fields.Many2one('ir.model.fields', _('Date Field'), required=True,
                                    domain="[('model_id', '=', model_id), ('ttype', 'in', ('date', 'datetime'))]",
                                    help=_('Date(time) field within the specified *Model* whose check may trigger the '
                                           'generation of a notification. When checking this field, if time '
                                           'information is present, it is simply ignored (e.g., "2017-01-25 09:30:00" '
                                           'is treated as "2017-01-25").'))
    date_number = fields.Integer(_('Number of Days'), required=True, default=0,
                                 help=_('- Negative integer: a notification is generated this number of days BEFORE '
                                        'the date set in *Date Field*\n'
                                        '- Positive integer: a notification is generated this number of days AFTER the '
                                        'date set in *Date Field*\n'
                                        '- Zero: a notification is generated right on the date set in *Date Field*'))

    notify_only_me = fields.Boolean(_('Notify Only Me'), required=True, default=True,
                                    help=_('If this flag is set, I will be the only person to be notified'))
    user_ids = fields.Many2many('res.users', 'alarm_user_rel', 'alarm_id', 'user_id', _('Explicit Users to Notify'))
    user_field_id = fields.Many2one('ir.model.fields', _('User Field'),
                                    domain="[('model_id', '=', model_id), "
                                           "('ttype', 'in', ['many2one', 'one2many', 'many2many']), "
                                           "('relation', '=', 'res.users')]",
                                    help=_('User field within the specified *Model* containing the user(s) to be '
                                           'notified.\n\n'
                                           'If *Notify Only Me* is set, I will be the only person to be notified but I '
                                           'must be also the user specified in this field.'))
    notification_message = fields.Text(_('Notification Message'),
                                       help=_('Information that will be provided to the notified users. Here we can '
                                              'provide static information but also dynamic information. To provide '
                                              'dynamic information we must use MAKO templates (same technique as the '
                                              'one used in email templates). For example, if we have an alarm for '
                                              'project tasks and we want to include in the message the name of the '
                                              'project manager, we can use the following template: '
                                              '${object.manager_id.name}.'))

    state = fields.Selection([('draft', _('Draft')),
                              ('done', _('Done')),
                              ('cancelled', _('Cancelled'))], _('State'), required=True, default='draft')

    current_user_group = fields.Selection([('notification_user', _('Notification User')),
                                           ('alarm_user', _('Alarm User')),
                                           ('manager', _('Manager'))], _('User Group of Current User'),
                                          compute=_compute_current_user_group,
                                          default=lambda self: self.get_current_user_group())

    # ===========
    # ORM METHODS
    # ===========

    @api.model
    def default_get(self, fields_list):
        defaults = super(Alarm, self).default_get(fields_list)

        active_model = self.env.context.get('active_model', False)
        active_ids = self.env.context.get('active_ids', False)

        if active_model and active_ids:
            models_ = self.env['ir.model'].search([('model', '=', active_model)])

            if models_:
                defaults['model_id'] = models_[0].id
                defaults['model_domain'] = "[('id', 'in', {0})]".format(active_ids)

        return defaults

    # ==================
    # CONSTRAINT METHODS
    # ==================

    @api.constrains('model_id', 'model_domain')
    def _check_model_and_domain(self):
        self.ensure_one()

        self.eval_model_and_domain()

    @api.constrains('user_field_id', 'user_ids')
    def _check_users_to_notify(self):
        self.ensure_one()

        if not self.notify_only_me and not self.user_field_id and not self.user_ids:
            raise ValidationError(_('No user set to be notified. Please set the "Notify Only Me" flag or specify a '
                                    'user field or add a user to the list of explicit users to notify.'))

    # ================
    # ONCHANGE METHODS
    # ================

    @api.onchange('model_id')
    def onchange_model(self):
        self.ensure_one()

        self.date_field_id = False
        self.user_field_id = False

    # ==============
    # BUTTON METHODS
    # ==============

    def do_preview_notification_message(self):
        self.ensure_one()

        return {
            'name': 'Notification Message Preview',
            'type': 'ir.actions.act_window',
            'res_model': 'alarm.notification.message.preview',
            'view_type': 'form',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'default_model_to_preview': self.model_id.model,
                'default_notification_message': self.notification_message,
            }
        }

    def do_trigger(self):
        self.ensure_one()

        num_process_records, num_notified_users = self.trigger()

        info_dialog_message = _('<b>{0} records</b> ({1}) have been <b>found</b> using the specified '
                                '<i>record selection</i> and <i>date condition</i> criteria.<br/><br/>'
                                '<b>{2} alarm notifications</b> have been <b>generated</b> following the specified '
                                '<i>notification</i> parameters.<br/><br/>'
                                '(Note that one record may generate zero, one or multiple notifications.)<br/>'
                                '(Also note that if a particular notification was already generated in the past, it is '
                                'not generated again.)')

        return {
            'name': _('Alarm Triggered'),
            'type': 'ir.actions.act_window',
            'res_model': 'alarm.info.dialog',
            'view_type': 'form',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'info_dialog_message': info_dialog_message.format(num_process_records, self.model_id.name,
                                                                  num_notified_users)
            }
        }

    def trigger(self):
        today_date = date.today()
        today_str = today_date.strftime('%Y-%m-%d')
        now_str = fields.Datetime.now()

        num_processed_records = 0
        num_notified_users = 0

        for alarm in self:
            model_name = alarm.model_id.model
            date_field_name = alarm.date_field_id.name

            # All db operations are performed taking into account the access rights of the user that created the alarm
            new_env = alarm.env(user=alarm.create_uid)

            notification_obj = self.env['alarm.notification'].with_env(new_env)
            email_template_obj = self.env['mail.template'].with_env(new_env)
            record_to_notify_obj = self.env[model_name].with_env(new_env)

            # Searches for records fulfilling the model domain and the date condition
            model_domain = alarm.eval_model_and_domain()

            if alarm.date_field_id.ttype == 'date':
                date_to_check = today_date - timedelta(days=alarm.date_number)
                date_domain = [(date_field_name, '=', date_to_check.strftime('%Y-%m-%d'))]
            else:
                user_tz_str = alarm.create_uid.tz or u'Africa/Sao_Tome'  # Africa/Sao_Tome is like UTC (+0:00)
                user_tz = pytz.timezone(user_tz_str)
                today_datetime_naive = datetime(year=today_date.year, month=today_date.month, day=today_date.day,
                                                hour=0, minute=0)
                today_datetime_utc = user_tz.localize(today_datetime_naive, is_dst=None).astimezone(pytz.utc)

                date_to_check_1 = today_datetime_utc - timedelta(days=alarm.date_number)
                date_to_check_2 = today_datetime_utc - timedelta(days=alarm.date_number - 1)

                date_domain = [(date_field_name, '>=', date_to_check_1.strftime('%Y-%m-%d %H:%M:%S')),
                               (date_field_name, '<', date_to_check_2.strftime('%Y-%m-%d %H:%M:%S'))]

            if model_domain:
                search_conditions = date_domain + model_domain
            else:
                search_conditions = date_domain

            records_to_notify = record_to_notify_obj.search(search_conditions)

            # For each found record, a set of notifications is created (one per user to be notified)
            for record_to_notify in records_to_notify:
                notification_message = email_template_obj.render_template(alarm.notification_message, model_name,
                                                                          [record_to_notify.id])[record_to_notify.id]

                notification_values = {
                    'alarm_id': alarm.id,
                    'name': alarm.name,
                    'notification_message': notification_message,
                    'model_id': alarm.model_id.id,
                    'record': '{0},{1}'.format(model_name, record_to_notify.id),
                    'active_from': today_str,
                    'state': 'open'
                }

                notified_user_ids = []

                if alarm.user_field_id:
                    users = record_to_notify[alarm.user_field_id.name]

                    for user in users:
                        if (user.id not in notified_user_ids and
                            (not alarm.notify_only_me or user.id == alarm.create_uid.id)):
                            notification_values['user_id'] = user.id
                            new_notification_id = notification_obj.create_ignoring_duplicates(notification_values)
                            notified_user_ids.append(user.id)

                            if new_notification_id:
                                num_notified_users += 1

                if alarm.notify_only_me:
                    if not alarm.user_field_id:
                        notification_values['user_id'] = alarm.create_uid.id
                        new_notification_id = notification_obj.create_ignoring_duplicates(notification_values)
                        notified_user_ids.append(alarm.create_uid.id)

                        if new_notification_id:
                            num_notified_users += 1
                else:
                    for user in alarm.user_ids:
                        if user.id not in notified_user_ids:
                            notification_values['user_id'] = user.id
                            new_notification_id = notification_obj.create_ignoring_duplicates(notification_values)
                            notified_user_ids.append(user.id)

                            if new_notification_id:
                                num_notified_users += 1

                if notified_user_ids:
                    num_processed_records += 1

            alarm.triggered_on = now_str

        return num_processed_records, num_notified_users

    # ============
    # CRON METHODS
    # ============

    def cron_notify(self):
        alarms = self.search([('state', '=', 'done')])
        alarms.trigger()

    # ===========
    # AUX METHODS
    # ===========

    def get_current_user_group(self):
        current_user_group = False

        user_obj = self.env['res.users']

        notification_user = user_obj.has_group('alarm.group_alarm_notification_user')
        alarm_user = user_obj.has_group('alarm.group_alarm_user')
        manager = user_obj.has_group('alarm.group_alarm_manager')

        if manager:
            current_user_group = 'manager'
        elif alarm_user:
            current_user_group = 'alarm_user'
        elif notification_user:
            current_user_group = 'notification_user'

        return current_user_group

    def eval_model_and_domain(self):
        '''
        Checks if the user that created the alarm has access rights for the specified model and if they do, checks that
        the specified model domain is valid.
        '''
        self.ensure_one()

        try:
            if not self.model_domain:
                model_domain = ''
                quick_verification_search_domain = [('id', '=', 0)]
            else:
                model_domain = safe_eval(self.model_domain, {'my_uid': self.create_uid.id,
                                                             'date': date,
                                                             'datetime': datetime,
                                                             'timedelta': timedelta})
                quick_verification_search_domain = ['&', ('id', '=', 0)] + model_domain

            new_env = self.env(user=self.create_uid)
            self.env[self.model_id.model].with_env(new_env).search(quick_verification_search_domain)
        except AccessError as e:
            raise e
        except Exception as e:
            raise ValidationError(_('Invalid model domain'))

        return model_domain
